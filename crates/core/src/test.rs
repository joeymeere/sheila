use crate::{Error, Result};
use chrono::{DateTime, Utc};
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use strum_macros::EnumString;

use std::collections::{HashMap, HashSet};
use std::fmt;

use std::path::PathBuf;
use std::time::Duration;
use uuid::Uuid;

pub type TestFn = Box<dyn Fn(TestContext) -> Result<()> + Send + Sync + 'static>;

pub struct Test {
    pub id: Uuid,
    pub test_fn: TestFn,
    pub attributes: TestAttributes,
    pub meta: TestMetadata,
    pub params: Option<IndexMap<String, serde_json::Value>>,
}

impl Test {
    pub fn new<S: Into<String>, F>(name: S, test_fn: F) -> Self
    where
        F: Fn(TestContext) -> Result<()> + Send + Sync + 'static,
    {
        let name = name.into();
        Self {
            id: Uuid::new_v4(),
            test_fn: Box::new(test_fn),
            attributes: TestAttributes::default(),
            meta: TestMetadata::new(name),
            params: None,
        }
    }

    pub fn with_attributes(mut self, attributes: TestAttributes) -> Self {
        self.attributes = attributes;
        self
    }

    pub fn with_metadata(mut self, metadata: TestMetadata) -> Self {
        self.meta = metadata;
        self
    }

    pub fn with_params(mut self, params: IndexMap<String, serde_json::Value>) -> Self {
        self.params = Some(params);
        self
    }

    pub fn ignore(mut self) -> Self {
        self.attributes.ignore = true;
        self
    }

    pub fn only(mut self) -> Self {
        self.attributes.only = true;
        self
    }

    pub fn retries(mut self, count: u32) -> Self {
        self.attributes.retries = count;
        self
    }

    pub fn timeout(mut self, timeout: Duration) -> Self {
        self.attributes.timeout = Some(timeout);
        self
    }

    pub fn tag<S: Into<String>>(mut self, tag: S) -> Self {
        self.attributes.tags.push(tag.into());
        self
    }

    pub fn category<S: Into<String>>(mut self, category: S) -> Self {
        self.attributes.category = Some(category.into());
        self
    }

    pub fn execute(&self, mut context: TestContext) -> TestResult {
        let mut result = TestResult::new(self.id, self.meta.name.clone(), self.meta.clone());

        if let Some(ref params) = self.params {
            context.params = params.clone();
        }

        result.start();

        let execution_result = (self.test_fn)(context);

        match execution_result {
            Ok(()) => result.finish(TestStatus::Passed, None),
            Err(error) => result.finish(TestStatus::Failed, Some(error)),
        }

        result
    }

    pub fn should_ignore(&self) -> bool {
        self.attributes.ignore
    }

    pub fn is_only(&self) -> bool {
        self.attributes.only
    }

    pub fn get_timeout(&self) -> Option<Duration> {
        self.attributes.timeout
    }
}

impl fmt::Debug for Test {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Test")
            .field("id", &self.id)
            .field("attributes", &self.attributes)
            .field("meta", &self.meta)
            .field("params", &self.params)
            .finish_non_exhaustive()
    }
}

/// TODO: this might be better served using generic parameters.
/// Overall it'd allow for more flexibility while having better type safety
/// guarantees, and a lot of the remaining boilerplate could be generated by macros.
#[derive(Debug, Clone)]
pub struct TestContext {
    pub id: Uuid,
    pub meta: TestMetadata,
    pub fixtures: IndexMap<String, String>,
    pub params: IndexMap<String, serde_json::Value>,
    pub shared: IndexMap<String, serde_json::Value>,
}

impl TestContext {
    pub fn new(id: Uuid, meta: TestMetadata) -> Self {
        Self {
            id,
            meta,
            fixtures: IndexMap::new(),
            params: IndexMap::new(),
            shared: IndexMap::new(),
        }
    }

    pub fn get_fixture<T: 'static>(&self, name: &str) -> Result<&str> {
        self.fixtures
            .get(name)
            .map(|s| s.as_str())
            .ok_or_else(|| Error::fixture(format!("Fixture '{}' not found or wrong type", name)))
    }

    pub fn get_parameter<T>(&self, name: &str) -> Result<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        self.params
            .get(name)
            .ok_or_else(|| Error::test_setup(format!("Parameter '{}' not found", name)))
            .and_then(|v| serde_json::from_value(v.clone()).map_err(Error::from))
    }

    pub fn set_shared<T>(&mut self, key: &str, value: T) -> Result<()>
    where
        T: Serialize,
    {
        let json_value = serde_json::to_value(value)?;
        self.shared.insert(key.to_string(), json_value);
        Ok(())
    }

    pub fn get_shared<T>(&self, key: &str) -> Result<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        self.shared
            .get(key)
            .ok_or_else(|| Error::generic(format!("Shared data '{}' not found", key)))
            .and_then(|v| serde_json::from_value(v.clone()).map_err(Error::from))
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, EnumString)]
pub enum TestStatus {
    #[strum(serialize = "pending")]
    Pending,
    #[strum(serialize = "running")]
    Running,
    #[strum(serialize = "passed")]
    Passed,
    #[strum(serialize = "failed")]
    Failed,
    #[strum(serialize = "skipped")]
    Skipped,
    #[strum(serialize = "ignored")]
    Ignored,
    #[strum(serialize = "timeout")]
    Timeout,
    #[strum(serialize = "cancelled")]
    Cancelled,
}

impl fmt::Display for TestStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TestStatus::Pending => write!(f, "pending"),
            TestStatus::Running => write!(f, "running"),
            TestStatus::Passed => write!(f, "passed"),
            TestStatus::Failed => write!(f, "failed"),
            TestStatus::Skipped => write!(f, "skipped"),
            TestStatus::Ignored => write!(f, "ignored"),
            TestStatus::Timeout => write!(f, "timeout"),
            TestStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Modifiers (quite evidently) modify the behavior of a test.
/// They can be included both statically, or conditionally at runtime within the test body.
///
/// ## Examples:
///
/// - A test might be marked as `#[fixme]` to indicate issues with the
/// test, signaling to runners that it should be skipped.
/// - Tests may depend on some specific result from a fixture, and the test won't
/// be useful without that result -- so the following conditional is added at the
/// beginning of the test body:
///
/// ```ignore
/// let result = fixture.get_result();
/// if result.is_none() {
///     return ctx.skip("Fixture result is none");
/// }
/// ```
///
/// This is a modifier that can be applied to the test, and will cause the test to
/// be skipped if the fixture result is none.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TestModifier {
    Skip(String),
    Fail(String),
    Fixme(String),
    Slow(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestAttributes {
    /// Ignore this test
    pub ignore: bool,
    /// Only run this test
    pub only: bool,
    /// Number of retries on failure
    pub retries: u32,
    /// Timeout in seconds
    pub timeout: Option<Duration>,
    /// Tags for identifying the test
    pub tags: Vec<String>,
    /// Category (unit, integration, e2e, etc.)
    pub category: Option<String>,
    /// Arbitrary custom attributes
    pub custom: HashMap<String, serde_json::Value>,
}

impl Default for TestAttributes {
    fn default() -> Self {
        Self {
            ignore: false,
            only: false,
            retries: 0,
            timeout: None,
            tags: Vec::new(),
            category: None,
            custom: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestMetadata {
    pub name: String,
    pub description: Option<String>,
    pub author: Option<String>,
    pub version: Option<String>,
    pub file: Option<String>,
    pub line: Option<u32>,
    pub module_path: Option<String>,

    /// Applied annotations for this test
    ///
    /// These are arbitrary notes that can be applied
    /// both upfront and at runtime, which will end up
    /// in the test report.
    pub annotations: HashSet<String>,

    pub modifiers: HashSet<TestModifier>,
}

impl TestMetadata {
    pub fn new(name: String) -> Self {
        Self {
            name,
            description: None,
            author: None,
            version: None,
            annotations: HashSet::new(),
            modifiers: HashSet::new(),
            file: None,
            line: None,
            module_path: None,
        }
    }

    pub fn with_annotation<V>(mut self, value: V) -> Self
    where
        V: Into<String>,
    {
        self.annotations.insert(value.into());
        self
    }

    pub fn with_modifier(mut self, modifier: TestModifier) -> Self {
        self.modifiers.insert(modifier);
        self
    }

    pub fn with_description<S: Into<String>>(mut self, description: S) -> Self {
        self.description = Some(description.into());
        self
    }

    pub fn with_author<S: Into<String>>(mut self, author: S) -> Self {
        self.author = Some(author.into());
        self
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    pub id: Uuid,
    pub name: String,
    pub meta: TestMetadata,
    pub status: TestStatus,

    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub duration: Option<Duration>,

    pub error: Option<Error>,
    pub stdout: Option<String>,
    pub stderr: Option<String>,
    pub retry_count: u32,
}

impl TestResult {
    pub fn new(id: Uuid, name: String, meta: TestMetadata) -> Self {
        Self {
            id,
            name,
            status: TestStatus::Pending,
            start_time: Utc::now(),
            end_time: None,
            duration: None,
            error: None,
            stdout: None,
            stderr: None,
            retry_count: 0,
            meta,
        }
    }

    pub fn start(&mut self) {
        self.status = TestStatus::Running;
        self.start_time = Utc::now();
    }

    pub fn finish(&mut self, status: TestStatus, error: Option<Error>) {
        self.status = status;
        self.end_time = Some(Utc::now());
        self.error = error;

        if let Some(end_time) = self.end_time {
            self.duration = Some(Duration::from_millis(
                (end_time - self.start_time).num_milliseconds() as u64,
            ));
        }
    }

    pub fn passed(&self) -> bool {
        self.status == TestStatus::Passed
    }

    pub fn failed(&self) -> bool {
        matches!(self.status, TestStatus::Failed | TestStatus::Timeout)
    }

    pub fn skipped(&self) -> bool {
        matches!(self.status, TestStatus::Skipped | TestStatus::Ignored)
    }
}

pub fn format_relative_path(path: &PathBuf) -> String {
    let current = std::env::current_dir().unwrap();
    path.strip_prefix(&current)
        .unwrap()
        .to_string_lossy()
        .to_string()
}
